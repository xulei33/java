/*------------------------------------------------------------
Copyright (C) 2007 SAS Institute, Inc. All rights reserved.

Notice:
  The following permissions are granted provided that the
  above copyright and this notice appear in the code and
  any related documentation. Permission to copy, modify
  and distribute the C language source code generated using
  or distributed with SAS Enterprise Miner C scoring component
  and any executables derived from such source code is
  limited to customers of SAS Institute with a valid license
  for SAS Enterprise Miner software. Any distribution
  of such executables or source code shall be on an "AS IS"
  basis without warranty of any kind.  SAS and all other SAS
  Institute. Inc. product and service names are registered
  trademarks or trademarks of SAS Institute Inc. in the USA
  and other countries. Except as contained in this notice,
  the name of the SAS Institute, SAS Enterprise Miner and
  SAS Enterprise Miner Cscore software shall not be used in
  the advertising or promotion of products or services without
  prior written authorization from SAS Institute Inc.
------------------------------------------------------------*/

/*-----------------------------------------------------------------
 *  This is the header file for the score function generated by
 *  SAS/Enterprise Miner C scoring component.
 *
 *  Product:     SAS Enterprise Miner
 *  Author:      SAS Institute
 *  Date:        November 16, 2010
 *
 *-----------------------------------------------------------------*/
#include <time.h>
#include <math.h>
#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include <stdarg.h>
#include <stdlib.h>

/*-----------------------------------------------------------------
 * to disable the code to support the SAS Standalone formats
 *  modify the FMTLIB macro to evaluate to 0.
 *-----------------------------------------------------------------*/
#define FMTLIB 1

#if FMTLIB == 1
#include "jazz.h"
#endif

/*----------------------------------------------------------------
 * Missing Value definition
 *  In the score function there is only 1 value for a double
 *  that signifies a missing value. That special value is in most
 *  cases an IEEE "NaN" value or "Not a Number". The value
 *  varies according to the system the function is to run on.
 *  The byte order for several systems are as follows:
 *
 *     AIX                    - big endian    - 0xFFFFFE0000000000
 *     HP-UX on PA-RISC       - big endian    - 0xFFFFFE0000000000
 *     HP-UX on Itanium       - little endian - 0x0000000000FEFFFF
 *     Linux for x64 (x86-64) - little endian - 0x0000000000FEFFFF
 *     Linux 32-bit (x86)     - little endian - 0x0000000000FEFFFF
 *     Solaris on sparc       - big endian    - 0xFFFFFE0000000000
 *     Solaris on amd64       - little endian - 0x0000000000FEFFFF
 *     Windows                - little endian - 0x0000000000D1FFFF
 *
 *  Modify the byte specification for MISSING below to fit your target
 *  environment's missing value.
 *---------------------------------------------------------------*/
 /* for Windows (little endian) */
#define WIN_LE_MISSING  (*((double*)"\0\0\0\0\0\xD1\xff\xff"))

/* for UNIX little endian systems */
#define UNX_LE_MISSING  (*((double*)"\0\0\0\0\0\xfe\xff\xff"))

/* for UNIX big endian systems */
#define UNX_BE_MISSING  (*((double*)"\xff\xff\xfe\0\0\0\0"))

/* Set the system specific value of missing  */
#define MISSING  WIN_LE_MISSING

/*-----------------------------------------------------------------
 * score function keywords for Windows DLL
 *  Modify the keywords to fit your environment
 *-----------------------------------------------------------------*/
#define SFDKeyWords   extern  __declspec( dllexport )

/*-----------------------------------------------------------------
 * select search routine used for user written formats
 * for ASCII systems define TBLORDRD = 1
 * for EBCDIC systems define TBLORDRD = 0
 *-----------------------------------------------------------------*/
#define TBLORDRD  1

/*-----------------------------------------------------------------
 * Redefines for SAS K functions
 *-----------------------------------------------------------------*/
#define ktrim trim
#define kleft left

/*-----------------------------------------------------------------
 * Redefines for SAS math.h functions
 *-----------------------------------------------------------------*/
#define arcos acos
#define arsin asin

/*-----------------------------------------------------------------
 * Cscore Prototypes
 *-----------------------------------------------------------------*/
#ifdef min
#undef min
#endif
double min(double,double);
int    n(int, ...);
double nmax(int,double, ...);
int    nmiss(int, ...);
char*  nput(double,char*,double,double,char*);
char*  cput(char*,char*,double,double,char*);
int    in(int,char*, ...);
int    index(char*, char*);
char*  left(char*);
int    length(char*);
char*  lsubstr(char*,double,double,char*);
char*  pad(char *,int);
char*  sascfmt(char*,char*,double,double,char*);
char*  sasnfmt(double,char*,double,double,char*);
char*  strip(char*);
int    streq(char*,char*);
int    strlt(char*,char*);
int    strgt(char*,char*);
int    strlteq(char*,char*);
int    strgteq(char*,char*);
char*  substr(char*,int,int,char*);
int    strcom(char*, char*);
char*  strncpyn(char*, size_t, char*);
char*  trim(char*);
char*  upcase(char*);
char*  dmnormcp(char*,int,char*);
char*  dmnormip(char*,int);
double dmran(double);
double dmint(double);
double probnorm(double);
double logcnorm(double);
double evalpoly(double*, int, double*);
double ln1px(double*);

/*-----------------------------------------------------------------
 * UsrFmt defines and prototypes
 *-----------------------------------------------------------------*/
#define USREL    0x80
#define USREH    0x40
#define USRNED   0x10
#define USRH     0x02
#define USRL     0x01
#define USRPIC   0x01
#define USRDMLT  10
typedef struct {
       double           lower;
       double           upper;
       unsigned short   flags;
       char             *label;
       char             *prefix;
       char              fill;
       double            mult;
} usrNbucket;

typedef struct {
       char             *lower;
       char             *upper;
       unsigned short   flags;
       char             *label;
} usrCbucket;


typedef struct {
       char*            name;
       double           fuzz;
       int              width;
       int              bucketStart;
       int              numBuckets;
       int              other;
       int              missOffset;
       unsigned short   flags;
} usrFormat;

int        usrFmtFind(const void*, const void*);
int        usrNbucketCompare(const void*, const void*);
int        usrCbucketCompare(const void*, const void*);
char*      usrTail(char*, int);
char*      usrPic(double, usrNbucket*, int, char* );

usrNbucket usrnBuckets[];
usrFormat  usrnFormats[];
usrCbucket usrcBuckets[];
usrFormat  usrcFormats[];

int        usrNumNfmts;
int        usrNumCfmts;

char*      usrnfmt(double,char*,double,double,char*);
char*      usrcfmt(char*,char*,double,double,char*);

/*-----------------------------------------------------------------
 * DMRAM function macros and seeds x and c, c < MULTIPLIER
 *----------------------------------------------------------------*/
#define MULTIPLIER 1234567815UL
#define LOMULT (MULTIPLIER & 0xFFFF)
#define HIMULT (MULTIPLIER >> 16)
static unsigned long x = 0;
static unsigned long c = (unsigned long ) -1;

/*-----------------------------------------------------------------
 * Score code Macros
 *----------------------------------------------------------------*/
#define ismiss(a) nmiss(1, a)
#define missingn(a) nmiss(1, a)
#define mod(x,y) fmod(x,y)

/*----------------------------------------------------------------
 * Type definitions
 *---------------------------------------------------------------*/
typedef char char32[32];

/*-----------------------------------------------------------------
 * Functions
 *----------------------------------------------------------------*/

/*-----------------------------------------------------------------
 * return the smaller signed number
 *-----------------------------------------------------------------*/
double min(double x, double y)
{
    return (x < y ? x : y);
}

/*-----------------------------------------------------------------
 * return count of non-missing args
 *-----------------------------------------------------------------*/
int n(int a, ...)
{
    va_list vl;
    double  num;
    int     narg, count=0;
    int i;

    if (a<1) return (1);
    narg = a;

    va_start (vl, a);

    for (i=0; i<narg; i++)
    {  num = va_arg( vl, double);
            if (memcmp(&num, &(MISSING), sizeof(double)) != 0) count++;
    }
    va_end (vl);
    return (count);
}

/*-----------------------------------------------------------------
 * return the max value found in the argument list
 *-----------------------------------------------------------------*/
double
nmax(int cnt, double val1, ...)
{
    va_list ap;
    double val_n;
    double maxval;

    va_start(ap, val1);
    maxval = val1;

    while (cnt-- > 1 )
    {
        val_n = va_arg(ap, double);
        maxval = (((maxval) > (val_n)) ? (maxval) : (val_n));
    }
    va_end(ap);
    return maxval;
}

/*-----------------------------------------------------------------
 * return count of the argument values that are missing values
 *-----------------------------------------------------------------*/
int
nmiss(int a, ...)
{
    va_list vl;
    double  num;
    int     narg, count=0;
    int     i;

    if (a<1) return (1);
    narg = a;

    va_start (vl, a);

    for (i=0; i<narg; i++)
    {
        num = va_arg( vl, double);
        if (memcmp(&num, &(MISSING), sizeof(double))==0) count++;
    }

    va_end (vl);

    return (count);
}

/*-----------------------------------------------------------------
 * convert number value to SAS formatted string
 *-----------------------------------------------------------------*/
char*
sasnfmt(double inval, char* format, double width, double decsize, char* outstr )
{
#if FMTLIB != 1
    if (strcmp(format, "BEST") == 0)
    {
       double intpart = 0;
       double fractpart = 0;
       int len = 0;
       int p = 0;
       int i = 0;
       int zerocnt = 0;

       if ( nmiss(1, inval) )
       {
           sprintf(outstr, "%-*s", (int)width, ".");
           return outstr;
       }

       fractpart = modf(inval, &intpart);
       sprintf(outstr, "%-d", (int)intpart);
       len = strlen(outstr);
       if ((int)width > len && fractpart != 0)
       {
           p = ((int)width)-(len+1);
           sprintf(outstr, "%.*f", p, inval);
           for (i = ((int)width)-1; (outstr[i] == '0') && (i > 0); i--)
               zerocnt++;
           if (zerocnt)
              sprintf(outstr, "%*.*f", (int)width, (p - zerocnt), inval);
       }
       return outstr;
    }
    else /* not BEST */
       return NULL;

#else

    ptr    fmtcode = NULL;
    long   rc = 0;
    struct X_FMTPAR fmtpar;
    int    namelen = 0;

    memset(&fmtpar,0,sizeof(struct X_FMTPAR));

    fmtpar.from.floc = &inval;
    fmtpar.fromw = sizeof(double);

    fmtpar.to.cloc = (unsigned char*)outstr;
    fmtpar.tow = (int)width;

    fmtpar.w = (int)width;
    fmtpar.d = (int)decsize;

    namelen = strlen(format);

    rc = xfname(format,namelen,'F',NULL,&fmtcode);

    if (rc == 0)               /* if SAS format found           */
    {
        rc = xffmt(&fmtpar, fmtcode);

        if ((rc != 0) && (rc != 2))
        {
            printf("SCORE ERROR: nput with format \"%s\" failed.\n", format);
            exit(103);
        }
        else
        {
            outstr[(int)width] = '\0'; /* add null terminator    */
            return outstr;
        }
    }
    else                                /* if not found in fmtlib       */
       return NULL;
#endif
}

/*-----------------------------------------------------------------
 * convert number value to formatted string
 *-----------------------------------------------------------------*/
char*
nput(double inval, char* format, double width, double decsize, char* outstr )
{
   if (sasnfmt(inval, format, width, decsize, outstr) == NULL)
   {
      if (usrnfmt(inval, format, width, decsize, outstr) == NULL)
          {
              printf("SCORE ERROR: nput with format \"%s\" failed.\n", format);
              exit(103);
          }
   }
   return outstr;
}

/*-----------------------------------------------------------------
 * convert character string to SAS formatted string
 *-----------------------------------------------------------------*/
char*
sascfmt(char* instr, char* format, double width, double decsize,char* outstr )
{
#if FMTLIB != 1
    {
        if ((strcmp(format,"$CHAR") == 0) || (strcmp(format,"$") == 0))
        {
            sprintf(outstr, "%.*s", (int)width, instr);
            outstr = pad(outstr, (int)width);
            return outstr;
        }
        else
           return NULL;
    }
#else /* FMTLIB defined */
    {
        int    instrlen = 0;
        ptr    fmtcode = NULL;
        long   rc = 0;
        struct X_FMTPAR fmtpar;
        int    namelen = 0;

        instrlen= strlen(instr);
        memset(&fmtpar,0,sizeof(struct X_FMTPAR));

        fmtpar.from.cloc = (unsigned char*)instr;
        fmtpar.fromw = instrlen;

        instr = strip(instr);
        fmtpar.to.cloc = (unsigned char*)outstr;
        fmtpar.tow = (int)width; /* setting the "pad to width"     */

        fmtpar.w = (int)width;   /* number of chars from source    */
        fmtpar.d = (int)decsize;

        namelen = strlen(format);

        rc = xfname(format,namelen,'F',NULL,&fmtcode);

        if (rc == 0)          /* if SAS format found               */
        {
            rc = xffmt(&fmtpar, fmtcode);
            if (rc != 0)
            {
                printf("SCORE ERROR: cput with format \"%s\" failed.\n", format);
                exit(103);
            }
            else
            {
                outstr[(int)width] = '\0';  /* add null terminator    */
                return outstr;
            }
        }
        else                                /* if not found in fmtlib       */
           return NULL;
    }
#endif
}

/*-----------------------------------------------------------------
 * convert string to formatted string
 *-----------------------------------------------------------------*/
char*
cput(char* instr, char* format, double width, double decsize,char* outstr )
{
    instr = strip(instr);
    if (sascfmt(instr, format, width, decsize, outstr) == NULL)
       if (usrcfmt(instr, format, width, decsize, outstr) == NULL)
       {
           printf("SCORE ERROR: cput with format \"%s\" failed.\n", format);
           exit(103);
       }
    return outstr;
}

/*-----------------------------------------------------------------
 * return 1/true if the target string is in the argument list
 *-----------------------------------------------------------------*/
int
in( int cnt, char* targ, ...)
{
    va_list ap;
    char* mem;

    va_start(ap, targ);
    while ( cnt -- > 1)
    {
        mem = va_arg(ap, char*);
        if ( strcmp(targ, mem) == 0 )
        {
            va_end(ap);
            return 1;
        }
    }
    va_end(ap);
    return 0;
}

/*-----------------------------------------------------------------
 * The index function searches src, from left to right, for the
 * first occurrence of the string specified in excerpt, and returns
 * the position in src of the excerpt string's first character. If
 * the string is not found in src, INDEX returns a value of 0. If
 * there are multiple occurrences of the string, INDEX returns only
 * the position of the first occurrence.
 *-----------------------------------------------------------------*/
int
index(char* src, char* excerpt)
{
   char* loc;
   int i;

   loc = strstr(src, excerpt);
   i = 0;
   if (loc != NULL) {
      for (; loc >= src; src++)
         i++;
   }

   return i;
}

/*-----------------------------------------------------------------
 * remove leading blanks from a string by shifting the first
 * non-space character and all subsequent characters to the
 * beginning of the string
 *-----------------------------------------------------------------*/
char*
left(char* s)
{
    char* p;
    char* d;
    int len;

    d=s;
    p=s;

    len = strlen(s);
    while (isspace(*p))
       p++;

    while ((*d = *p) != '\0')
       d++, p++;

    pad(s,len);

    return s;
}

/*-----------------------------------------------------------------
 * return length of string ignoring trailing blanks
 * Note empty string or string of all spaces returns 1
 *-----------------------------------------------------------------*/
int
length( char* s1)
{
    int len;

    len = strlen(s1);

    while ( (len > 0) && (isspace(s1[len - 1])))
       len --;
    if (len < 1)
       len = 1;
    return len;
}

/*-----------------------------------------------------------------
 * append string2 to string1 starting at position in string1.
 * terminate string1 after num characters are appended
 *-----------------------------------------------------------------*/
char*
lsubstr( char* s1, double position, double num, char* s2)
{
    int pos;
    int i;
    int padto = 0;
    int s1_len;

    pos = (int)position;
    s1_len = strlen(s1);
    if ( num < 0)
    {
        num = strlen(s2); /* use all chars from right side */
        padto = s1_len;
    }

    pos = pos -1; /* convert to 0 based strings */
    for (i = 0; (i < num) && (s2[i] != '\0') ; i++)
    {
        if (padto && (s1[pos+i] == '\0') )
           break;
        else
           s1[pos + i] = s2[i];
    }

    while ( (padto >= pos + i ) && (s1[pos + i] != '\0') )
    {
        s1[pos + i] = ' ';
        i++;
    }

    while (!padto && (pos +i < s1_len) )
        i++;

    s1[pos + i] = '\0';

    return s1;
}

/*-----------------------------------------------------------------
 * determine if the argument string is all blanks
 *-----------------------------------------------------------------*/
int
missingc( char* s1)
{
    int i = 0;

    while ( s1[i] != '\0')
    {
        if (s1[i] != ' ')
           return 0; /* not missing */
        i++;
    }
    return 1; /* all blanks is missing */
}

/*-----------------------------------------------------------------
 * pad a string to the specified length with trailing blanks
 *-----------------------------------------------------------------*/
char*
pad(char * str, int len)
{
   int index;

   for (index = strlen(str); index < len; index ++)
   {
       str[index] = ' ';
   }
   str[index] = '\0';
   return str;
}

/*-----------------------------------------------------------------
 * copy chars from src to dest starting with first for num chars
 *-----------------------------------------------------------------*/
char *
substr( char* src, int first, int num, char * dest)
{
    int i;
    int start = first -1;

    if ( num < 0)
    {
        num = strlen(src);      /* all chars from right side        */
    }

    for ( i=0; (i < num) && (src[start + i] != '\0'); i++)
       dest[i] = src[start + i];
    dest[i] = '\0';
    return dest;
}

/*-----------------------------------------------------------------
 * copy strings like SAS truncating at size and null terminates.
 * Note: requires dest to be allocated destsize + 1.
 *-----------------------------------------------------------------*/
char*
strncpyn(char* dest, size_t destsize, char* src)
{
    strncpy(dest, src, destsize);
    if (strlen(src) >= destsize)
       dest[destsize] = '\0';
    return dest;
}

/*-----------------------------------------------------------------
 * null terminate string after last contiguous non-space character
 *-----------------------------------------------------------------*/
char*
trim(char* s)
{
    char* p;

    p = s + strlen(s) - 1;
    while (isspace(*p))
       p--;
    p[1] = '\0';
    return (s);
}

/*-----------------------------------------------------------------
 * uppercase all lower case characters in a string
 *-----------------------------------------------------------------*/
char*
upcase(char* s)
{
    int i;

    for ( i=0; s[i]!= '\0'; i++)
       if (islower(s[i]))
          s[i] = (char) toupper(s[i]);
    return(s);
}

/*--------------------------------------------------------------------------
 * probnorm computes the cumulative of the normal distribution, i.e.,
 *            the integral from -infinity to x of
 *              (1/sqrt(2*pi)) exp(-u*u/2) du
 *
 * Method:    The rational function approximation from pages 90-92 of
 *            Kennedy  and Gentle,  Statistical  Computing, Marcel Dekker,
 *            NY 1980.
 *-----------------------------------------------------------------*/
double probnorm(double x)
{
    static double xnum1[4] = { 242.66795523053175,21.979261618294152,\
                               6.9963834886191355,-.035609843701815385 };
    static double xden1[4] = { 215.0588758698612,91.164905404514901,\
                              15.082797630407787,1. };
    static double xnum2[8] = { 300.4592610201616005,451.9189537118729422,\
                               339.320816734343687,152.9892850469404039,\
                               43.1622272220567353,7.211758250883093659,\
                               .5641955174789739711, -1.368648573827167067e-7 };
    static double xden2[8] = { 300.4592609569832933,790.9509253278980272,\
                               931.3540948506096211,638.9802644656311665,\
                               277.5854447439876434,77.00015293522947295,\
                               12.78272731962942351,1. };
    static double xnum3[5] = { -.00299610707703542174, -.0494730910623250734,\
                               -.22695659353968693,-.278661308609647788,\
                               -.0223192459734184686 };
    static double xden3[5] = { .0106209230528467918,.191308926107829841,\
                               1.05167510706793207,1.98733201817135256,1. };

    static double pim12 = .5641895835477562869480795; /*  pim12 is pi**(-1/2) */

    static double sqrt2 = 1.4142135623730950488;  /* sqrt2 is sqrt(2)       */

    double ret_val, d_1;
    static double derf, derfc, z, z2;
    static int qdirct;
    static double zm2;

    if ((int)((fabs(x) < 1e-30)))
    {
        ret_val = (float).5;
    }
    else if (x <= -38.)
    {
        ret_val = (float)0.;
    }
    else if (x <= -15.)
    {
        ret_val = exp((logcnorm(x)));
    }
    else if (x > 6.)
    {
        ret_val = (float)1.;
    }
    else
    {
        z = (d_1 = x / sqrt2, fabs(d_1));
        z2 = z * z;
        zm2 = 1. / z2;
        if (z < .5)
        {
            derf = z * evalpoly(xnum1, 4, &z2) / evalpoly(xden1, 4, &z2);
            qdirct = 1; /* true */
        }
        else if (z < 4.)
        {
            derfc = exp(-z2) * evalpoly(xnum2, 8, &z) / evalpoly(xden2, 8, & z);
            qdirct = 0; /* false */
        }
        else
        {
            derfc = exp(-z2) / z * (pim12 + zm2 * evalpoly(xnum3, 5, &zm2) /
                       evalpoly(xden3, 5, &zm2));
            qdirct = 0; /* false */
        }

        if ((x >= 0.))
        {
            if (! qdirct)
                derf = 1. - derfc;
            ret_val = (derf + 1.) / 2.;
        }
        else
        {
            if (qdirct)
                derfc = 1. - derf;
            ret_val = derfc / 2.;
        }
    }
    return ret_val;
} /* probnorm */

/*-----------------------------------------------------------------
 * evalpoly evaluates a polynomial at x and returns
 *          a(1) + a(2)*x + ... + a(n)*x**(n-1)
 * where:
 * double *a is an array of coefficients of the polynomial
 * int n is the length of a, also degree of polynomial - 1
 * double *x is a point at which the poly is to be evaluated
 *---------------------------------------------------------------*/
double evalpoly(double* a, int n, double* x)
{
    double ret_val;
    static double term;
    static int i;

    --a;                            /* array pointer decrement      */
    term = a[n];
    for (i = n - 1; i >= 1; --i)
        term = a[i] + term * *x;
    ret_val = term;
    return ret_val;
} /* evalpoly */


/*------------------------------------------------------------------
 * logcnorm computes the logarithm of the cumulative normal
 *          distribution from abs( x ) to infinity for
 *          abs( x ) >= 5.
 *
 *  note: abs(x) must be >= 5 else there is an error exit.
 *
 *-----------------------------------------------------------------*/
double logcnorm(double x)
{
    static double coef[12] = { -1.,3.,-15.,105.,-945.,10395.,-135135., \
            2027025.,-34459425.,654729075.,-13749310575.,316234143225. };
    double ret_val, d_1;
    static double correc, xx;
    static double approx, xx2;

    xx = fabs(x);
    if (xx < 5.)
    {
        printf("SCORE ERROR: argument too small in logcnorm().\n");
        exit(291);
    }
    approx = -.91893853320467274177 - xx * (float).5 * xx - log(xx);
    xx2 = xx * xx;
    d_1 = 1. / xx2;
    correc = evalpoly(coef, 12, &d_1) / xx2;
    correc = ln1px(&correc);
    ret_val = approx + correc;
    return ret_val;
} /* logcnorm */

/*-----------------------------------------------------------------
 * ln1px returns ln(1+x)
 *
 * note that the obvious code of log(1.0+x) won't work for small
 * x because 1.0+x loses accuracy
 *-----------------------------------------------------------------*/
double ln1px(double* a)
{
    static double p1 = -1.29418923021993;
    static double p2 = .405303492862024;
    static double p3 = -.0178874546012214;
    static double q1 = -1.62752256355323;
    static double q2 = .747811014037616;
    static double q3 = -.0845104217945565;

    double ret_val;
    static double t, w, x, t2;

    if (fabs(*a) > .375)
    {
        x = *a + 1.;
        ret_val = log(x);
    }
    else
    {
        t = *a / (*a + 2.);
        t2 = t * t;
        w = (((p3 * t2 + p2) * t2 + p1) * t2 + 1.) / (((q3 * t2 + q2) * \
        t2 + q1) * t2 + 1.);
        ret_val = t * 2. * w;
    }
    return ret_val;
} /* ln1px */

/*-----------------------------------------------------------------
 * dmran returns a value from the uniform distribution on the
 *       interval between 0 and 1.
 *-----------------------------------------------------------------*/
double
dmran( double ix)
{
    if (c == (unsigned long) -1)      /* check for initialization   */
    {
       c = 65437;                     /* internal seed always 65437 */
       x = (unsigned long)ix;
       if ( x <= 0)                   /* specified seed no good     */
          x =  time(NULL);            /* use time value             */
    }

    /* There are probably faster ways to code this,
     * but this is portable and correct                             */
    {
        unsigned long halves[4];
        unsigned long xlo, xhi, clo, chi;
        unsigned long temp;
        xlo = x & 0xFFFF;
        xhi = x >> 16;
        clo = c & 0xFFFF;
        chi = c >> 16;
        temp = xlo * LOMULT;
        halves[3] = temp & 0xFFFF;
        halves[2] = temp >> 16;
        temp = xlo * HIMULT;
        halves[2] += temp & 0xFFFF;
        halves[1] = (halves[2] >> 16) + (temp >> 16);
        halves[0] = halves[1] >> 16;
        halves[2] &= 0xFFFF;
        halves[1] &= 0xFFFF;
        temp = xhi * LOMULT;
        halves[2] += temp & 0xFFFF;
        halves[1] += (halves[2] >> 16) + (temp >> 16);
        halves[0] += halves[1] >> 16;
        halves[2] &= 0xFFFF;
        halves[1] &= 0xFFFF;
        temp = xhi * HIMULT;
        halves[1] += temp & 0xFFFF;
        halves[0] += (halves[1] >> 16) + (temp >> 16);
        halves[1] &= 0xFFFF;
        halves[3] += clo;
        halves[2] += chi + (halves[3] >> 16);
        halves[1] += halves[2] >> 16;
        halves[2] &= 0xFFFF;
        halves[3] &= 0xFFFF;
        halves[1] += (halves[0] << 16);
        halves[3] += (halves[2] << 16);
        x = halves[3];
        c = halves[1];
    }

    return x/4294967296.0;  /* 0.0 <= result < 1.0 */
}

/*-------------------------------------------------------------------
 *          user-defined format function definitions
 *-------------------------------------------------------------------*/

/*---------------------------------------------------------------------
 * format comparison routine used for binary search
 *--------------------------------------------------------------------*/
int
usrFmtFind(const void* p1, const void* p2)
{
    return strcmp ((char*) p1, (char* ) ((usrFormat *)p2)->name);
}

/*--------------------------------------------------------------------
 * numeric bucket comparison routine used for binary search
 *--------------------------------------------------------------------*/
int
usrNbucketCompare(const void* key, const void* bucket)
{
    double fuzz, value;
    usrNbucket* b;
    int flags, elow, ehigh;
    double lower, upper;
    b = (usrNbucket*) bucket;
    value = ((usrNbucket*) key)-> lower;
    fuzz = ((usrNbucket*) key)-> upper;
    flags = b->flags;
    lower = b->lower;
    upper = b->upper;
    elow  = flags & USREL;
    ehigh = flags & USREH;
    if (flags & USRL)
    {
        if (flags & USRH)
           return 0;
        if (ismiss(value))
           return 0;
        if (ehigh)
        {
            if (value < upper)
               return 0;
            else
               return 1;
        }
        if (value <= upper+fuzz)
           return 0;
        return 1;
    }
    if (flags & USRH)
    {
        if (elow)
        {
            if (value > lower)
               return 0;
            else
               return -1;
        }

        if (value >= lower-fuzz)
           return 0;
        return -1;
    }
    if (ismiss(value))
       return -1;
    if (!elow? (value<lower-fuzz):(value<=lower))
       return -1;
    if (!ehigh? (value>upper+fuzz):(value>=upper))
       return 1;
    return 0;
}

/*--------------------------------------------------------------------
 * string bucket comparison routine for binary search
 *--------------------------------------------------------------------*/
int
usrCbucketCompare(const void* str, const void* bucket)
{
    usrCbucket *b = (usrCbucket*) bucket;
    char* upper;
    char* lower;
    int left, right;

    lower=b->lower;
    upper=b->upper;

    left = strcmp(str, lower);
    if (!left)
       return 0;
    right = strcmp(str,upper);
    if (!right)
       return 0;

    if (left<0)
       return -1;
    if (right>0)
       return 1;
    return 0;
}

/*--------------------------------------------------------------------
 *  cut off head of string (instead of end) when width is too small for
 *  string length
 *--------------------------------------------------------------------*/
char*
usrTail(char* instr, int w)
{
    int len;
    char buf[200];
    char spf[10] ;

    len = strlen(instr);
    if (len == w)
       return instr;
    if (w > len)
    {
        strcpy(buf, instr);
        sprintf(spf, "%%%d.%ds", w, w);
        sprintf(instr, spf, buf);
        return instr;
    }
    strcpy(instr, instr+len-w);
    return instr;
}

/*-------------------------------------------------------------------
 * handle picture formats
 *-------------------------------------------------------------------*/
char*
usrPic(double dNum, usrNbucket* b, int width, char* buf)
{
    char charNum[64], fillchar;
    int preflen, numDec, buflen, i, j, len1, len2;
    char* digits;
    char fmtstr[20];
    char *prefix;
    int noedit;
    double mult;
    char fill;
    char *picStr;

    picStr = b->label;
    fill   = b->fill;
    prefix = b->prefix;
    mult   = b->mult;
    noedit = (b->flags) & USRNED;

    if (noedit)
    {
        strcpy(buf, picStr);
        return usrTail(buf, width);
    }

    preflen = strlen(prefix);
    len1 = strlen(picStr);
    for(i=0;i<len1  &&!isdigit(picStr[i]);i++) ;

    if (i==len1)
    {
        strcpy(buf, picStr);
        return usrTail(buf, width);
    }

    strcpy(buf, picStr+i);
    buflen = len1 - i;

    if (mult==USRDMLT)
    {
        numDec = 0;
        len1 = buflen - 1;
        for(i=len1;i>=0  &&!numDec;i--)
           if (buf[i] == '.')
              numDec = len1-i;
        mult = pow((double)10,(double)numDec);
    }


    sprintf(fmtstr, "%%%d", buflen);
    strcat(fmtstr, ".0f");
    sprintf(charNum, fmtstr, mult*dNum);

    i=0;
    while(charNum[i++]==' ');

    digits = charNum + i-1;

    len2 = strlen(digits);

    for (i=buflen, j=len2; i>0  &&j>0;)
    {
        if (isdigit(buf[--i]))
           buf[i]=digits[--j];
    }

    preflen--;
    for(j=i-1;j>=0;j--)
    {
        fillchar = (char)(preflen < 0 ? fill : prefix[preflen--]);
        if(isdigit(buf[j]))
        {
            buf[j] = (char) (buf[j]=='0' ? fillchar : '0');
        }
        else
            buf[j] = fillchar;
    }
    return usrTail(buf, width);
}

/*--------------------------------------------------------------------
 * user defined numeric format handler
 *-------------------------------------------------------------------*/
char*
usrnfmt(double val, char* fmtname, double width, double dec, char *outstr)
{
    usrNbucket *bucketStart, *bucket, key;
    int w;
    usrFormat* format;

    if (!usrNumNfmts) return NULL;

#if TBLORDRD
    /* depends on sorted table */
    format =  (usrFormat*) bsearch((void *) fmtname, (void *) usrnFormats, \
               usrNumNfmts, sizeof(usrFormat), usrFmtFind);
#else
    { /* table order independent */
        int i;
        format = NULL;
        for (i = 0; i < usrNumNfmts; i++)
        {
            if ( usrFmtFind( (char*) fmtname, &(usrnFormats[i])) == 0 )
            {
                format = &(usrnFormats[i]);
                break;
             }
         }
    }
#endif

    if (format == NULL)
       return NULL;

    w = (int) width;
    if (!w)
    {
        w = format->width;
    }

    bucketStart  = usrnBuckets+format->bucketStart;

    if (ismiss(val))
    {
        if (format->missOffset > -1)
           sprintf(outstr, "%-*s", w, usrnBuckets[format->missOffset].label);
        else
           sprintf(outstr, "%-*s",w,  ".");
        return outstr;

    }

    key.lower = val;
    key.upper = format->fuzz;

#if TBLORDRD
        /* depends on sorted table */
    bucket = (usrNbucket*) bsearch((void *) &key, (void *) bucketStart, \
             format->numBuckets, sizeof(usrNbucket), usrNbucketCompare);
#else
    { /* table order independent */
        int i;
        bucket = NULL;
        for (i = 0; i < format->numBuckets; i++)
        {
            if ( (usrNbucketCompare((const void*) &key, (const void*)&(bucketStart[i]))) == 0)
            {
                bucket = &(bucketStart[i]);
                break;
            }
        }
    }
#endif

    if (bucket==NULL)
    {
        if (format->other > -1)
        {
            if (format->flags & USRPIC)
               return usrPic(val, &usrnBuckets[format->other], w, outstr);

            sprintf(outstr, "%-*s", w, usrnBuckets[format->other].label);
            return outstr;
        }
        return sasnfmt(val,"BEST", (double)w, dec, outstr);
    }

    if (format->flags & USRPIC)
       return usrPic(val, bucket, w, outstr);

     sprintf(outstr, "%-*s",w, bucket->label);
     return outstr;
}
/*---------------------------------------------------------------------
 * user-defined character format handler
 *--------------------------------------------------------------------*/
char*
usrcfmt(char* str, char* fmtname, double width, double dec, char *outstr)
{
    int w;
    usrFormat* format;
    usrCbucket *bucketStart, *bucket;

    if (!usrNumCfmts)
       return NULL;

#if TBLORDRD
    /* depends on sorted table */
    format = (usrFormat*) bsearch((void*) fmtname, (void *) usrcFormats, \
                usrNumCfmts, sizeof(usrFormat), usrFmtFind);
#else
    { /* table order independent */
        int i;
        format = NULL;
        for (i = 0; i < usrNumCfmts; i++)
        {
            if ( usrFmtFind( (char*) fmtname, &(usrcFormats[i])) == 0 )
            {
                format = &(usrcFormats[i]);
                 break;
            }
        }
    }
#endif

    if (format==NULL)
    {
       return NULL;
    }

    w = (int) width;
    if (!w)
       w = format->width;
    bucketStart  = usrcBuckets+format->bucketStart;

#if TBLORDRD
     /* depends on sorted table */
     bucket = (usrCbucket*) bsearch((void*) str, (void *) bucketStart, \
     format->numBuckets, sizeof(usrCbucket), usrCbucketCompare);
#else
    { /* table order independent */
        int i;
        bucket = NULL;
        for (i = 0; i < format->numBuckets; i++)
        {
            if ( (usrCbucketCompare((const void*) str, \
                  (const void*)&(bucketStart[i]))) == 0)
            {
                bucket = &(bucketStart[i]);
                break;
            }
        }
    }
#endif

    if (bucket==NULL)
    {
        if (format->other > -1)
           sprintf(outstr, "%-*s", w, usrcBuckets[format->other].label);
        else
           sprintf(outstr, "%-*s", w, str);
    }
    else
       sprintf(outstr, "%-*s", w, bucket->label);
    return outstr;
}

/*-----------------------------------------------------------------
 * dmint returns the integral portion of the argument (truncates
 * the decimal portion).
 *-----------------------------------------------------------------*/
double
dmint( double d )
{
   if ( d < 0 )
      return ceil(d);
   else
      return floor(d);
}

/*--------------------------------------------------------------------
 *  strcom returns the relative difference in the string arguments
 *
 *------------------------------------------------------------------*/
int
strcom(char *str1, char *str2)
{
    int   len1;
    int   len2;
    char *c1;
    char *c2;
    int   j;
    int   m;

    c1 = (char *)str1;
    c2 = (char *)str2;

    len1 = strlen(str1);
    len2 = strlen(str2);

    m = ((len1) < (len2) ? (len1) : (len2));
    for (j = 1; j <= m; ++j)
    {
        if (*c1++ != *c2++)
           return((*--c1 < *--c2) ? -j : j);
    }

    if (len1 == len2)
       return(0);

    if (len1 < len2)
    {
        for (; j <= len2; ++j)
           if (*c2++ != ' ')
              return((*--c2 > (char)' ') ? -j : j);
    }
    else
    {
        /* len1 is > len2  */
        for (; j <= len1; ++j)
           if (*c1++ != ' ')
              return((*--c1 < (char)' ') ? -j : j);
    }

   /* Equal...  */
    return(0);
}

/*-----------------------------------------------------------------
 * Returns string with leading and trailing blanks removed.
 *-----------------------------------------------------------------*/
char*
strip(char *str)
{
   return((trim(left(str))));
}

/*-----------------------------------------------------------------
 * compare strings ignoring trailing blanks
 *-----------------------------------------------------------------*/
int
streq(char *str1,char *str2)
{
   return((strcom(str1,str2) == 0) ? 1 : 0);
}

/*--------------------------------------------------------------------
 *  strlt returns true if str1 is less than str2
 *------------------------------------------------------------------*/
int
strlt(char *str1,char *str2)
{
   return((strcom(str1,str2) < 0) ? 1 : 0);
}

/*--------------------------------------------------------------------
 *  strgt returns true if str1 is greater than str2
 *------------------------------------------------------------------*/
int
strgt(char *str1,char *str2)
{
   return((strcom(str1,str2) > 0) ? 1 : 0);
}

/*--------------------------------------------------------------------
 *  strlteq returns true if str1 is less than or equal to str2
 *------------------------------------------------------------------*/
int
strlteq(char *str1,char *str2)
{
   return((strcom(str1,str2) <= 0) ? 1 : 0);
}

/*--------------------------------------------------------------------
 *  strgteq returns true if str1 is greater than or equal to str2
 *------------------------------------------------------------------*/
int
strgteq(char *str1,char *str2)
{
   return((strcom(str1,str2) >= 0) ? 1 : 0);
}

/*--------------------------------------------------------------------
 *  dmnormcp copies and normalizes a string
 *------------------------------------------------------------------*/
char* dmnormcp(char* str_in, int maxlen, char* str_out)
{
   char* result;
   int inlen;

   result = str_out;

   while (isspace(*str_in))    /* trim any leading spaces           */
       str_in++;

   str_in = trim(str_in);      /* trim any trailing spaces          */

   inlen = strlen(str_in);     /* set length                        */
   if (inlen > maxlen)
      inlen = maxlen;

   while (inlen--!= 0)         /* copy each character in upper case */
   {
     *(str_out++) = toupper(*(str_in++));
   }

   *str_out = '\0';            /* null terminate                    */
   return result;
}

/*--------------------------------------------------------------------
 *  dmnormip normalizes a string in place
 *------------------------------------------------------------------*/
char* dmnormip(char *str, int maxlen)
{
   char * result;
   char * dest;
   int len;

   dest = result = str;
   while (isspace(*str))       /* trim any leading spaces           */
       str++;

   str = trim(str);            /* trim any trailing spaces          */

   len = strlen(str);          /* set length                        */
   if (len > maxlen)
      len = maxlen;

  while (len--!= 0)            /* move each character and upper case*/
   *(dest++) = toupper(*(str++));

   *dest = '\0';               /* null terminate                    */
   return result;
}

/*--------------------------------------------------------------------
 *  stripcpy copies a string removing leading and trailing blanks
 *-------------------------------------------------------------------*/
char* stripcpy(char* str_in, int maxlen, char* str_out)
{
   char* result;
   int inlen;

   result = str_out;

   while (isspace(*str_in))    /* trim any leading spaces           */
       str_in++;

   str_in = trim(str_in);      /* trim any trailing spaces          */

   inlen = strlen(str_in);     /* set length                        */
   if (inlen > maxlen)
      inlen = maxlen;

   while (inlen-- != 0)       /* copy each character in upper case */
   {
      *(str_out++) = *(str_in++);
   }
   *str_out = '\0';            /* null terminate                    */
   return result;
}
